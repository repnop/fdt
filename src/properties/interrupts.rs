pub mod pci;

use super::{cells::AddressCells, PHandle, Property};
use crate::{
    cell_collector::{BuildCellCollector, CellCollector, CollectCellsError},
    helpers::{FallibleNode, FallibleRoot},
    nodes::{root::Root, Node},
    parsing::{aligned::AlignedParser, BigEndianU32, NoPanic, Panic, ParserWithMode},
    FdtError,
};

/// Enum representing the two possibilities for interrupt descriptions on a
/// devicetree node. See the documentation for each type for more information.
/// [`ExtendedInterrupts`] will take precedence if both properties exist.
pub enum Interrupts<'a, P: ParserWithMode<'a> = (AlignedParser<'a>, Panic)> {
    Legacy(LegacyInterrupts<'a, P>),
    Extended(ExtendedInterrupts<'a, P>),
}

impl<'a, P: ParserWithMode<'a>> Property<'a, P> for Interrupts<'a, P> {
    fn parse(node: FallibleNode<'a, P>, root: FallibleRoot<'a, P>) -> Result<Option<Self>, FdtError> {
        match ExtendedInterrupts::parse(node, root)? {
            Some(extended) => Ok(Some(Self::Extended(extended))),
            None => match LegacyInterrupts::parse(node, root)? {
                Some(legacy) => Ok(Some(Self::Legacy(legacy))),
                None => Ok(None),
            },
        }
    }
}

/// [Devicetree 2.4.1.1.
/// `interrupts`](https://devicetree-specification.readthedocs.io/en/latest/chapter2-devicetree-basics.html#interrupts)
///
/// The `interrupts` property of a device node defines the interrupt or
/// interrupts that are generated by the device. The value of the `interrupts`
/// property consists of an arbitrary number of interrupt specifiers. The format
/// of an interrupt specifier is defined by the binding of the interrupt domain
/// root.
///
/// `interrupts` is overridden by the `interrupts-extended` property and
/// normally only one or the other should be used.
pub struct LegacyInterrupts<'a, P: ParserWithMode<'a> = (AlignedParser<'a>, Panic)> {
    interrupt_parent: InterruptParent<'a, P>,
    interrupt_cells: InterruptCells,
    encoded_array: &'a [u8],
}

impl<'a, P: ParserWithMode<'a>> LegacyInterrupts<'a, P> {
    pub fn interrupt_parent(self) -> InterruptParent<'a, P> {
        self.interrupt_parent
    }

    pub fn iter<I: CellCollector>(self) -> LegacyInterruptsIter<'a, I> {
        LegacyInterruptsIter {
            interrupt_cells: self.interrupt_cells,
            encoded_array: self.encoded_array,
            _collector: core::marker::PhantomData,
        }
    }
}

impl<'a, P: ParserWithMode<'a>> Property<'a, P> for LegacyInterrupts<'a, P> {
    fn parse(node: FallibleNode<'a, P>, root: FallibleRoot<'a, P>) -> Result<Option<Self>, FdtError> {
        match node.properties()?.find("interrupts")? {
            Some(interrupts) => {
                let interrupt_parent = match InterruptParent::<(P::Parser, NoPanic)>::parse(node, root)? {
                    Some(p) => p,
                    None => return Err(FdtError::MissingRequiredProperty("interrupt-parent")),
                };

                let Some(interrupt_cells) = interrupt_parent.property::<InterruptCells>()? else {
                    return Err(FdtError::MissingRequiredProperty("interrupt-cells"));
                };

                if interrupts.value().len() % (interrupt_cells.0 * 4) != 0 {
                    return Err(FdtError::InvalidPropertyValue);
                }

                Ok(Some(Self {
                    interrupt_parent: InterruptParent(interrupt_parent.0.alt()),
                    interrupt_cells,
                    encoded_array: interrupts.value(),
                }))
            }
            None => Ok(None),
        }
    }
}

impl<'a, P: ParserWithMode<'a>> Copy for LegacyInterrupts<'a, P> {}
impl<'a, P: ParserWithMode<'a>> Clone for LegacyInterrupts<'a, P> {
    fn clone(&self) -> Self {
        *self
    }
}

pub struct LegacyInterruptsIter<'a, I: CellCollector> {
    interrupt_cells: InterruptCells,
    encoded_array: &'a [u8],
    _collector: core::marker::PhantomData<*mut I>,
}

impl<'a, I: CellCollector> Iterator for LegacyInterruptsIter<'a, I> {
    type Item = Result<I::Output, CollectCellsError>;
    fn next(&mut self) -> Option<Self::Item> {
        let encoded_specifier = self.encoded_array.get(..self.interrupt_cells.0 * 4)?;
        let mut specifier_collector = <I as CellCollector>::Builder::default();

        for encoded_specifier in encoded_specifier.chunks_exact(4) {
            // TODO: replace this stuff with `array_chunks` when its stabilized
            //
            // These unwraps can't panic because `chunks_exact` guarantees that
            // we'll always get slices of 4 bytes
            if let Err(e) = specifier_collector.push(u32::from_be_bytes(encoded_specifier.try_into().unwrap())) {
                return Some(Err(e));
            }
        }

        self.encoded_array = self.encoded_array.get(self.interrupt_cells.0 * 4..)?;
        Some(Ok(I::map(specifier_collector.finish())))
    }
}

/// [Devicetree 2.4.1.3.
/// `interrupts-extended`](https://devicetree-specification.readthedocs.io/en/latest/chapter2-devicetree-basics.html#interrupts-extended)
///
/// The `interrupts-extended` property lists the interrupt(s) generated by a
/// device. `interrupts-extended` should be used instead of interrupts when a
/// device is connected to multiple interrupt controllers as it encodes a parent
/// `phandle` with each interrupt specifier.
///
/// Example:
///
/// This example shows how a device with two interrupt outputs connected to two
/// separate interrupt controllers would describe the connection using an
/// `interrupts-extended` property. `pic` is an interrupt controller with an
/// `#interrupt-cells` specifier of 2, while `gic` is an interrupt controller
/// with an `#interrupts-cells` specifier of 1.
///
/// `interrupts-extended = <&pic 0xA 8>, <&gic 0xda>;`
pub struct ExtendedInterrupts<'a, P: ParserWithMode<'a> = (AlignedParser<'a>, Panic)> {
    root: Root<'a, P>,
    encoded_array: &'a [u8],
}

impl<'a, P: ParserWithMode<'a>> ExtendedInterrupts<'a, P> {
    pub fn iter(self) -> ExtendedInterruptsIter<'a, P> {
        ExtendedInterruptsIter { root: self.root, encoded_array: self.encoded_array }
    }
}

impl<'a, P: ParserWithMode<'a>> Property<'a, P> for ExtendedInterrupts<'a, P> {
    fn parse(node: FallibleNode<'a, P>, root: FallibleRoot<'a, P>) -> Result<Option<Self>, FdtError> {
        match node.properties()?.find("interrupts-extended")? {
            Some(interrupts) => {
                Ok(Some(Self { encoded_array: interrupts.value(), root: Root { node: root.node.alt() } }))
            }

            None => Ok(None),
        }
    }
}

pub struct ExtendedInterruptsIter<'a, P: ParserWithMode<'a> = (AlignedParser<'a>, Panic)> {
    root: Root<'a, P>,
    encoded_array: &'a [u8],
}

impl<'a, P: ParserWithMode<'a>> Iterator for ExtendedInterruptsIter<'a, P> {
    type Item = P::Output<ExtendedInterrupt<'a, P>>;

    #[track_caller]
    fn next(&mut self) -> Option<Self::Item> {
        let phandle = self
            .encoded_array
            .get(..4)
            .map(|bytes| PHandle(BigEndianU32::from_be(u32::from_ne_bytes(bytes.try_into().unwrap()))))?;
        self.encoded_array = self.encoded_array.get(4..)?;

        let res = crate::tryblock!({
            let root: FallibleRoot<'a, P> = Root { node: self.root.node.fallible() };
            let Some(interrupt_parent) = root.resolve_phandle(phandle)? else {
                return Err(FdtError::MissingPHandleNode(phandle.0.to_ne()));
            };

            let Some(interrupt_cells) = interrupt_parent.property::<InterruptCells>()? else {
                return Err(FdtError::MissingRequiredProperty("#interrupt-cells"));
            };

            let cells_length = interrupt_cells.0 * 4;
            let encoded_array = match self.encoded_array.get(..cells_length) {
                Some(bytes) => bytes,
                None => return Ok(None),
            };

            self.encoded_array = match self.encoded_array.get(cells_length..) {
                Some(bytes) => bytes,
                None => return Ok(None),
            };

            Ok(Some(ExtendedInterrupt {
                interrupt_parent: InterruptParent(interrupt_parent.alt()),
                interrupt_cells,
                encoded_array,
            }))
        });

        // This is a manual impl of `map` because we need the panic location to
        // be the caller if `P::to_output` panics
        #[allow(clippy::manual_map)]
        match res.transpose() {
            Some(output) => Some(P::to_output(output)),
            None => None,
        }
    }
}

/// A single entry in an `interrupts-extended` property
pub struct ExtendedInterrupt<'a, P: ParserWithMode<'a> = (AlignedParser<'a>, Panic)> {
    interrupt_parent: InterruptParent<'a, P>,
    interrupt_cells: InterruptCells,
    encoded_array: &'a [u8],
}

impl<'a, P: ParserWithMode<'a>> ExtendedInterrupt<'a, P> {
    pub fn interrupt_parent(self) -> InterruptParent<'a, P> {
        self.interrupt_parent
    }

    pub fn interrupt_cells(self) -> InterruptCells {
        self.interrupt_cells
    }

    pub fn interrupt_specifier(self) -> InterruptSpecifier<'a> {
        InterruptSpecifier { interrupt_cells: self.interrupt_cells, encoded_array: self.encoded_array }
    }
}

pub struct InterruptSpecifier<'a> {
    interrupt_cells: InterruptCells,
    encoded_array: &'a [u8],
}

impl<'a> InterruptSpecifier<'a> {
    /// Iterator over the components that comprise this interrupt specifier.
    pub fn iter(self) -> InterruptSpecifierIter<'a> {
        InterruptSpecifierIter { encoded_array: self.encoded_array }
    }

    /// Iterator over `(u32, u32)` interrupt specifier pairs, if
    /// `#interrupt-cells` value is `2`.
    pub fn iter_pairs(self) -> Option<InterruptSpecifierIterPairs<'a>> {
        if self.interrupt_cells.0 != 2 {
            return None;
        }

        Some(InterruptSpecifierIterPairs { encoded_array: self.encoded_array })
    }

    /// Extract the single component that comprises the interrupt specifier, if
    /// the `#interrupt-cells` value is `1`.
    pub fn single(self) -> Option<u32> {
        if self.interrupt_cells.0 != 1 {
            return None;
        }

        self.iter().next()
    }

    /// Extract the two components that comprise the interrupt specifier, if the
    /// `#interrupt-cells` value is `2`.
    pub fn pair(self) -> Option<(u32, u32)> {
        if self.interrupt_cells.0 != 2 {
            return None;
        }

        let mut iter = self.into_iter();
        Some((iter.next()?, iter.next()?))
    }
}

impl<'a> IntoIterator for InterruptSpecifier<'a> {
    type IntoIter = InterruptSpecifierIter<'a>;
    type Item = u32;

    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}

/// Iterator over individual components in an interrupt specifier
pub struct InterruptSpecifierIter<'a> {
    encoded_array: &'a [u8],
}

impl<'a> Iterator for InterruptSpecifierIter<'a> {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.encoded_array.is_empty() {
            return None;
        }

        let next = self.encoded_array.get(..4)?;
        self.encoded_array = self.encoded_array.get(4..)?;

        // This panic can never fail since the slice length is guaranteed to be
        // 4 bytes long
        Some(u32::from_be_bytes(next.try_into().unwrap()))
    }
}

/// Iterator over pairs of `u32`s representing an interrupt specifier
pub struct InterruptSpecifierIterPairs<'a> {
    encoded_array: &'a [u8],
}

impl<'a> Iterator for InterruptSpecifierIterPairs<'a> {
    type Item = (u32, u32);

    fn next(&mut self) -> Option<Self::Item> {
        if self.encoded_array.is_empty() {
            return None;
        }

        let (next, rest) = self.encoded_array.split_at_checked(8)?;
        self.encoded_array = rest;

        let (first, second) = next.split_at(4);

        // This panic can never fail since the slice length is guaranteed to be
        // 4 bytes long
        Some((u32::from_be_bytes(first.try_into().unwrap()), u32::from_be_bytes(second.try_into().unwrap())))
    }
}

/// [Devicetree 2.4.1.2.
/// `interrupt-parent`](https://devicetree-specification.readthedocs.io/en/latest/chapter2-devicetree-basics.html#interrupt-parent)
///
/// Because the hierarchy of the nodes in the interrupt tree might not match the
/// devicetree, the `interrupt-parent` property is available to make the
/// definition of an interrupt parent explicit. The value is the `phandle` to
/// the interrupt parent. If this property is missing from a device, its
/// interrupt parent is assumed to be its devicetree parent.
pub struct InterruptParent<'a, P: ParserWithMode<'a> = (AlignedParser<'a>, Panic)>(Node<'a, P>);

impl<'a, P: ParserWithMode<'a>> Copy for InterruptParent<'a, P> {}
impl<'a, P: ParserWithMode<'a>> Clone for InterruptParent<'a, P> {
    fn clone(&self) -> Self {
        *self
    }
}

impl<'a, P: ParserWithMode<'a>> core::ops::Deref for InterruptParent<'a, P> {
    type Target = Node<'a, P>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<'a, P: ParserWithMode<'a>> core::ops::DerefMut for InterruptParent<'a, P> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl<'a, P: ParserWithMode<'a>> Property<'a, P> for InterruptParent<'a, P> {
    fn parse(node: FallibleNode<'a, P>, root: FallibleRoot<'a, P>) -> Result<Option<Self>, FdtError> {
        match node.properties()?.find("interrupt-parent")? {
            Some(phandle) => match root.resolve_phandle(PHandle(phandle.as_value()?))? {
                Some(parent) => Ok(Some(Self(parent.alt()))),
                None => Err(FdtError::MissingPHandleNode(phandle.as_value()?)),
            },
            None => Ok(node.parent().map(|n| Self(n.alt()))),
        }
    }
}

/// [Devicetree 2.4.2.1.
/// `#interrupt-cells`](https://devicetree-specification.readthedocs.io/en/latest/chapter2-devicetree-basics.html#interrupt-cells)
///
/// The `#interrupt-cells` property defines the number of cells required to
/// encode an interrupt specifier for an interrupt domain.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct InterruptCells(pub usize);

impl<'a, P: ParserWithMode<'a>> Property<'a, P> for InterruptCells {
    fn parse(node: FallibleNode<'a, P>, _: FallibleRoot<'a, P>) -> Result<Option<Self>, FdtError> {
        match node.properties()?.find("#interrupt-cells")? {
            Some(ic) => Ok(Some(Self(ic.as_value()?))),
            None => Ok(None),
        }
    }
}

/// [Devicetree 2.4.3.2.
/// `interrupt-map-mask`](https://devicetree-specification.readthedocs.io/en/latest/chapter2-devicetree-basics.html#interrupt-map-mask)
///
/// An `interrupt-map-mask` property is specified for a nexus node in the
/// interrupt tree. This property specifies a mask that is `AND`ed with the
/// incoming unit interrupt specifier being looked up in the table specified in
/// the `interrupt-map` property.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct InterruptMapMask<AddrMask: CellCollector, IntMask: CellCollector> {
    address_mask: AddrMask::Output,
    interrupt_specifier_mask: IntMask::Output,
}

impl<AddrMask: CellCollector, IntMask: CellCollector> InterruptMapMask<AddrMask, IntMask> {
    pub fn mask(
        self,
        address: <AddrMask as CellCollector>::Output,
        interrupt_specifier: <IntMask as CellCollector>::Output,
    ) -> (<AddrMask as CellCollector>::Output, <IntMask as CellCollector>::Output)
    where
        <AddrMask as CellCollector>::Output:
            core::ops::BitAnd<<AddrMask as CellCollector>::Output, Output = <AddrMask as CellCollector>::Output>,
        <IntMask as CellCollector>::Output:
            core::ops::BitAnd<<IntMask as CellCollector>::Output, Output = <IntMask as CellCollector>::Output>,
    {
        (self.address_mask & address, self.interrupt_specifier_mask & interrupt_specifier)
    }
}

impl<'a, AddrMask: CellCollector, IntMask: CellCollector, P: ParserWithMode<'a>> Property<'a, P>
    for InterruptMapMask<AddrMask, IntMask>
{
    fn parse(node: FallibleNode<'a, P>, _: FallibleRoot<'a, P>) -> Result<Option<Self>, FdtError> {
        let address_cells =
            node.property::<AddressCells>()?.ok_or(FdtError::MissingRequiredProperty("#address-cells"))?;
        let interrupt_cells =
            node.property::<InterruptCells>()?.ok_or(FdtError::MissingRequiredProperty("#interrupt-cells"))?;
        match node.properties()?.find("interrupt-map-mask")? {
            Some(prop) => {
                if prop.value().len() % 4 != 0 {
                    return Err(FdtError::InvalidPropertyValue);
                }

                let mut address_collector = AddrMask::Builder::default();
                let mut specifier_collector = IntMask::Builder::default();
                let mut cells = prop.value().chunks_exact(4);

                // TODO: replace this stuff with `array_chunks` when its stabilized
                //
                // These unwraps can't panic because `chunks_exact` guarantees that
                // we'll always get slices of 4 bytes
                for chunk in cells.by_ref().take(address_cells.0) {
                    address_collector.push(u32::from_be_bytes(chunk.try_into().unwrap()))?;
                }

                for chunk in cells.take(interrupt_cells.0) {
                    specifier_collector.push(u32::from_be_bytes(chunk.try_into().unwrap()))?;
                }

                Ok(Some(Self {
                    address_mask: AddrMask::map(address_collector.finish()),
                    interrupt_specifier_mask: IntMask::map(specifier_collector.finish()),
                }))
            }
            None => Ok(None),
        }
    }
}

/// [Devicetree 2.4.2.2.
/// `interrupt-controller`](https://devicetree-specification.readthedocs.io/en/latest/chapter2-devicetree-basics.html#interrupt-controller)
///
/// The presence of an `interrupt-controller` property defines a node as an
/// interrupt controller node.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct InterruptController;

impl<'a, P: ParserWithMode<'a>> Property<'a, P> for InterruptController {
    fn parse(node: FallibleNode<'a, P>, _: FallibleRoot<'a, P>) -> Result<Option<Self>, FdtError> {
        match node.properties()?.find("interrupt-controller")? {
            Some(_) => Ok(Some(Self)),
            None => Ok(None),
        }
    }
}

pub struct InterruptMap<
    'a,
    CAddr: CellCollector,
    CInt: CellCollector = u32,
    PAddr: CellCollector = u64,
    PInt: CellCollector = u32,
    P: ParserWithMode<'a> = (AlignedParser<'a>, Panic),
> {
    address_cells: AddressCells,
    interrupt_cells: InterruptCells,
    node: FallibleNode<'a, P>,
    encoded_map: &'a [u8],
    _collectors: core::marker::PhantomData<*mut (CAddr, CInt, PAddr, PInt)>,
}

impl<
        'a,
        P: ParserWithMode<'a>,
        CAddr: CellCollector,
        CInt: CellCollector,
        PAddr: CellCollector,
        PInt: CellCollector,
    > InterruptMap<'a, CAddr, CInt, PAddr, PInt, P>
{
    pub fn iter(self) -> InterruptMapIter<'a, CAddr, CInt, PAddr, PInt, P> {
        InterruptMapIter {
            address_cells: self.address_cells,
            interrupt_cells: self.interrupt_cells,
            node: self.node,
            encoded_map: self.encoded_map,
            _collectors: core::marker::PhantomData,
        }
    }

    #[allow(clippy::type_complexity)]
    pub fn find(
        self,
        address: CAddr::Output,
        interrupt_specifier: CInt::Output,
    ) -> P::Output<Option<InterruptMapEntry<'a, CAddr, CInt, PAddr, PInt, P>>>
    where
        CAddr::Output: PartialEq,
        CInt::Output: PartialEq,
    {
        let this: InterruptMap<_, _, _, _, (P::Parser, NoPanic)> = InterruptMap {
            address_cells: self.address_cells,
            interrupt_cells: self.interrupt_cells,
            node: self.node,
            encoded_map: self.encoded_map,
            _collectors: self._collectors,
        };

        P::to_output(
            this.iter()
                .find(|e| match e {
                    Err(_) => true,
                    Ok(entry) => {
                        entry.child_unit_address == address && entry.child_interrupt_specifier == interrupt_specifier
                    }
                })
                .transpose()
                .map(|e| {
                    e.map(|e| InterruptMapEntry::<_, _, _, _, P> {
                        child_unit_address: e.child_unit_address,
                        child_interrupt_specifier: e.child_interrupt_specifier,
                        interrupt_parent: e.interrupt_parent.alt(),
                        parent_unit_address: e.parent_unit_address,
                        parent_interrupt_specifier: e.parent_interrupt_specifier,
                    })
                }),
        )
    }
}

impl<
        'a,
        P: ParserWithMode<'a>,
        CAddr: CellCollector,
        CInt: CellCollector,
        PAddr: CellCollector,
        PInt: CellCollector,
    > Property<'a, P> for InterruptMap<'a, CAddr, CInt, PAddr, PInt, P>
{
    fn parse(node: FallibleNode<'a, P>, _: FallibleRoot<'a, P>) -> Result<Option<Self>, FdtError> {
        let Some(encoded_map) = node.properties()?.find("interrupt-map")? else { return Ok(None) };

        let address_cells =
            node.property::<AddressCells>()?.ok_or(FdtError::MissingRequiredProperty("#address-cells"))?;
        let interrupt_cells =
            node.property::<InterruptCells>()?.ok_or(FdtError::MissingRequiredProperty("#interrupt-cells"))?;

        Ok(Some(InterruptMap {
            address_cells,
            interrupt_cells,
            node: node.alt(),
            encoded_map: encoded_map.value(),
            _collectors: core::marker::PhantomData,
        }))
    }
}

pub struct InterruptMapIter<
    'a,
    CAddr: CellCollector,
    CInt: CellCollector,
    PAddr: CellCollector,
    PInt: CellCollector,
    P: ParserWithMode<'a> = (AlignedParser<'a>, Panic),
> {
    address_cells: AddressCells,
    interrupt_cells: InterruptCells,
    node: FallibleNode<'a, P>,
    encoded_map: &'a [u8],
    _collectors: core::marker::PhantomData<*mut (CAddr, CInt, PAddr, PInt)>,
}

impl<
        'a,
        CAddr: CellCollector,
        CInt: CellCollector,
        PAddr: CellCollector,
        PInt: CellCollector,
        P: ParserWithMode<'a>,
    > Iterator for InterruptMapIter<'a, CAddr, CInt, PAddr, PInt, P>
{
    type Item = P::Output<InterruptMapEntry<'a, CAddr, CInt, PAddr, PInt, P>>;

    #[track_caller]
    fn next(&mut self) -> Option<Self::Item> {
        let res = crate::tryblock!({
            let child_addr_size = self.address_cells.0 * 4;
            let child_intsp_size = self.interrupt_cells.0 * 4;

            let Some((child_address_iter, rest)) = self.encoded_map.split_at_checked(child_addr_size) else {
                return Ok(None);
            };
            let Some((child_specifier_iter, rest)) = rest.split_at_checked(child_intsp_size) else {
                return Ok(None);
            };
            let Some((interrupt_parent, rest)) = rest.split_at_checked(4) else {
                return Ok(None);
            };

            let root = self.node.make_root::<(P::Parser, NoPanic)>()?;
            let phandle = u32::from_ne_bytes(interrupt_parent.try_into().unwrap());
            let interrupt_parent = root
                .resolve_phandle(PHandle(BigEndianU32::from_be(phandle)))?
                .ok_or(FdtError::MissingPHandleNode(phandle.swap_bytes()))?;

            let parent_address_cells = interrupt_parent
                .property::<AddressCells>()?
                .ok_or(FdtError::MissingRequiredProperty("#address-cells"))?;
            let parent_interrupt_cells = interrupt_parent
                .property::<InterruptCells>()?
                .ok_or(FdtError::MissingRequiredProperty("#interrupt-cells"))?;

            let parent_addr_size = parent_address_cells.0 * 4;
            let parent_intsp_size = parent_interrupt_cells.0 * 4;

            let Some((parent_address_iter, rest)) = rest.split_at_checked(parent_addr_size) else {
                return Ok(None);
            };

            let Some((parent_specifier_iter, rest)) = rest.split_at_checked(parent_intsp_size) else {
                return Ok(None);
            };
            self.encoded_map = rest;

            let mut child_address_collector = CAddr::Builder::default();
            for chunk in child_address_iter.chunks_exact(4) {
                child_address_collector.push(u32::from_be_bytes(chunk.try_into().unwrap()))?;
            }

            let mut child_specifier_collector = CInt::Builder::default();
            for chunk in child_specifier_iter.chunks_exact(4) {
                child_specifier_collector.push(u32::from_be_bytes(chunk.try_into().unwrap()))?;
            }

            let mut parent_address_collector = PAddr::Builder::default();
            for chunk in parent_address_iter.chunks_exact(4) {
                parent_address_collector.push(u32::from_be_bytes(chunk.try_into().unwrap()))?;
            }

            let mut parent_specifier_collector = PInt::Builder::default();
            for chunk in parent_specifier_iter.chunks_exact(4) {
                parent_specifier_collector.push(u32::from_be_bytes(chunk.try_into().unwrap()))?;
            }

            Ok(Some(InterruptMapEntry {
                interrupt_parent: interrupt_parent.alt(),
                child_unit_address: CAddr::map(child_address_collector.finish()),
                child_interrupt_specifier: CInt::map(child_specifier_collector.finish()),
                parent_unit_address: PAddr::map(parent_address_collector.finish()),
                parent_interrupt_specifier: PInt::map(parent_specifier_collector.finish()),
            }))
        });

        #[allow(clippy::manual_map)]
        match res.transpose() {
            Some(output) => Some(P::to_output(output)),
            None => None,
        }
    }
}

pub struct InterruptMapEntry<
    'a,
    CAddr: CellCollector,
    CInt: CellCollector,
    PAddr: CellCollector,
    PInt: CellCollector,
    P: ParserWithMode<'a>,
> {
    pub interrupt_parent: Node<'a, P>,
    pub child_unit_address: CAddr::Output,
    pub child_interrupt_specifier: CInt::Output,
    pub parent_unit_address: PAddr::Output,
    pub parent_interrupt_specifier: PInt::Output,
}

impl<
        'a,
        P: ParserWithMode<'a>,
        CAddr: CellCollector,
        CInt: CellCollector,
        PAddr: CellCollector,
        PInt: CellCollector,
    > Clone for InterruptMapEntry<'a, CAddr, CInt, PAddr, PInt, P>
where
    CAddr::Output: Clone,
    CInt::Output: Clone,
    PAddr::Output: Clone,
    PInt::Output: Clone,
{
    fn clone(&self) -> Self {
        Self {
            child_unit_address: self.child_unit_address.clone(),
            child_interrupt_specifier: self.child_interrupt_specifier.clone(),
            interrupt_parent: self.interrupt_parent,
            parent_unit_address: self.parent_unit_address.clone(),
            parent_interrupt_specifier: self.parent_interrupt_specifier.clone(),
        }
    }
}

impl<
        'a,
        P: ParserWithMode<'a>,
        CAddr: CellCollector,
        CInt: CellCollector,
        PAddr: CellCollector,
        PInt: CellCollector,
    > Copy for InterruptMapEntry<'a, CAddr, CInt, PAddr, PInt, P>
where
    CAddr::Output: Copy,
    CInt::Output: Copy,
    PAddr::Output: Copy,
    PInt::Output: Copy,
{
}
